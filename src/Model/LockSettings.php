<?php
/**
 * LockSettings
 *
 * PHP version 5
 *
 * @category Class
 * @package  Coucounco\Airkey\Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */

/**
 * EVVA AirKey Cloud API
 *
 * No description provided (generated by Swagger Codegen https://github.com/swagger-api/swagger-codegen)
 *
 * OpenAPI spec version: v18.0.4
 * Contact: office-wien@evva.com
 * Generated by: https://github.com/swagger-api/swagger-codegen.git
 * Swagger Codegen version: 2.4.41
 */

/**
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen
 * Do not edit the class manually.
 */

namespace Coucounco\Airkey\Swagger\Client\Model;

use \ArrayAccess;
use \Coucounco\Airkey\Swagger\Client\ObjectSerializer;

/**
 * LockSettings Class Doc Comment
 *
 * @category Class
 * @description Model that describes lock settings. Most settings need the lock to be synchronized via card reader or smartphone to be in effect. Check maintenance tasks to see if the lock needs to be synchronized.
 * @package  Coucounco\Airkey\Swagger\Client
 * @author   Swagger Codegen team
 * @link     https://github.com/swagger-api/swagger-codegen
 */
class LockSettings implements ModelInterface, ArrayAccess
{
    const DISCRIMINATOR = null;

    /**
      * The original name of the model.
      *
      * @var string
      */
    protected static $swaggerModelName = 'LockSettings';

    /**
      * Array of property to type mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerTypes = [
        'id' => 'int',
        'version' => 'int',
        'ownership' => 'string',
        'last_synchronized_on' => 'string',
        'timezone' => 'string',
        'holiday_calendar_enabled' => 'bool',
        'manual_office_mode_enabled' => 'bool',
        'automatic_office_mode_enabled' => 'bool',
        'normal_release_duration' => 'int',
        'extended_release_duration' => 'int',
        'unlock_sync_mode' => 'string',
        'rs485_log_output_enabled' => 'bool',
        'allow_handsfree_mode' => 'bool',
        'anonymize_event_log' => '\Coucounco\Airkey\Swagger\Client\Model\AnonymizeEventLog',
        'anonymize_data_in_owner_protocol' => 'bool',
        'office_mode_slots' => '\Coucounco\Airkey\Swagger\Client\Model\OfficeModeSlot[]',
        'assigned_areas' => '\Coucounco\Airkey\Swagger\Client\Model\AssignedArea[]',
        'active_shares' => '\Coucounco\Airkey\Swagger\Client\Model\ActiveShare[]',
        'sharing_codes' => '\Coucounco\Airkey\Swagger\Client\Model\SharingCode[]'
    ];

    /**
      * Array of property to format mappings. Used for (de)serialization
      *
      * @var string[]
      */
    protected static $swaggerFormats = [
        'id' => 'int64',
        'version' => 'int64',
        'ownership' => null,
        'last_synchronized_on' => null,
        'timezone' => null,
        'holiday_calendar_enabled' => null,
        'manual_office_mode_enabled' => null,
        'automatic_office_mode_enabled' => null,
        'normal_release_duration' => 'int32',
        'extended_release_duration' => 'int32',
        'unlock_sync_mode' => null,
        'rs485_log_output_enabled' => null,
        'allow_handsfree_mode' => null,
        'anonymize_event_log' => null,
        'anonymize_data_in_owner_protocol' => null,
        'office_mode_slots' => null,
        'assigned_areas' => null,
        'active_shares' => null,
        'sharing_codes' => null
    ];

    /**
     * Array of property to type mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerTypes()
    {
        return self::$swaggerTypes;
    }

    /**
     * Array of property to format mappings. Used for (de)serialization
     *
     * @return array
     */
    public static function swaggerFormats()
    {
        return self::$swaggerFormats;
    }

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @var string[]
     */
    protected static $attributeMap = [
        'id' => 'id',
        'version' => 'version',
        'ownership' => 'ownership',
        'last_synchronized_on' => 'lastSynchronizedOn',
        'timezone' => 'timezone',
        'holiday_calendar_enabled' => 'holidayCalendarEnabled',
        'manual_office_mode_enabled' => 'manualOfficeModeEnabled',
        'automatic_office_mode_enabled' => 'automaticOfficeModeEnabled',
        'normal_release_duration' => 'normalReleaseDuration',
        'extended_release_duration' => 'extendedReleaseDuration',
        'unlock_sync_mode' => 'unlockSyncMode',
        'rs485_log_output_enabled' => 'rs485LogOutputEnabled',
        'allow_handsfree_mode' => 'allowHandsfreeMode',
        'anonymize_event_log' => 'anonymizeEventLog',
        'anonymize_data_in_owner_protocol' => 'anonymizeDataInOwnerProtocol',
        'office_mode_slots' => 'officeModeSlots',
        'assigned_areas' => 'assignedAreas',
        'active_shares' => 'activeShares',
        'sharing_codes' => 'sharingCodes'
    ];

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @var string[]
     */
    protected static $setters = [
        'id' => 'setId',
        'version' => 'setVersion',
        'ownership' => 'setOwnership',
        'last_synchronized_on' => 'setLastSynchronizedOn',
        'timezone' => 'setTimezone',
        'holiday_calendar_enabled' => 'setHolidayCalendarEnabled',
        'manual_office_mode_enabled' => 'setManualOfficeModeEnabled',
        'automatic_office_mode_enabled' => 'setAutomaticOfficeModeEnabled',
        'normal_release_duration' => 'setNormalReleaseDuration',
        'extended_release_duration' => 'setExtendedReleaseDuration',
        'unlock_sync_mode' => 'setUnlockSyncMode',
        'rs485_log_output_enabled' => 'setRs485LogOutputEnabled',
        'allow_handsfree_mode' => 'setAllowHandsfreeMode',
        'anonymize_event_log' => 'setAnonymizeEventLog',
        'anonymize_data_in_owner_protocol' => 'setAnonymizeDataInOwnerProtocol',
        'office_mode_slots' => 'setOfficeModeSlots',
        'assigned_areas' => 'setAssignedAreas',
        'active_shares' => 'setActiveShares',
        'sharing_codes' => 'setSharingCodes'
    ];

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @var string[]
     */
    protected static $getters = [
        'id' => 'getId',
        'version' => 'getVersion',
        'ownership' => 'getOwnership',
        'last_synchronized_on' => 'getLastSynchronizedOn',
        'timezone' => 'getTimezone',
        'holiday_calendar_enabled' => 'getHolidayCalendarEnabled',
        'manual_office_mode_enabled' => 'getManualOfficeModeEnabled',
        'automatic_office_mode_enabled' => 'getAutomaticOfficeModeEnabled',
        'normal_release_duration' => 'getNormalReleaseDuration',
        'extended_release_duration' => 'getExtendedReleaseDuration',
        'unlock_sync_mode' => 'getUnlockSyncMode',
        'rs485_log_output_enabled' => 'getRs485LogOutputEnabled',
        'allow_handsfree_mode' => 'getAllowHandsfreeMode',
        'anonymize_event_log' => 'getAnonymizeEventLog',
        'anonymize_data_in_owner_protocol' => 'getAnonymizeDataInOwnerProtocol',
        'office_mode_slots' => 'getOfficeModeSlots',
        'assigned_areas' => 'getAssignedAreas',
        'active_shares' => 'getActiveShares',
        'sharing_codes' => 'getSharingCodes'
    ];

    /**
     * Array of attributes where the key is the local name,
     * and the value is the original name
     *
     * @return array
     */
    public static function attributeMap()
    {
        return self::$attributeMap;
    }

    /**
     * Array of attributes to setter functions (for deserialization of responses)
     *
     * @return array
     */
    public static function setters()
    {
        return self::$setters;
    }

    /**
     * Array of attributes to getter functions (for serialization of requests)
     *
     * @return array
     */
    public static function getters()
    {
        return self::$getters;
    }

    /**
     * The original name of the model.
     *
     * @return string
     */
    public function getModelName()
    {
        return self::$swaggerModelName;
    }

    const OWNERSHIP_OWNER = 'OWNER';
    const OWNERSHIP_EXTERNAL = 'EXTERNAL';
    const UNLOCK_SYNC_MODE_ALWAYS = 'ALWAYS';
    const UNLOCK_SYNC_MODE_PERIODICALLY = 'PERIODICALLY';
    const UNLOCK_SYNC_MODE_NEVER = 'NEVER';
    

    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getOwnershipAllowableValues()
    {
        return [
            self::OWNERSHIP_OWNER,
            self::OWNERSHIP_EXTERNAL,
        ];
    }
    
    /**
     * Gets allowable values of the enum
     *
     * @return string[]
     */
    public function getUnlockSyncModeAllowableValues()
    {
        return [
            self::UNLOCK_SYNC_MODE_ALWAYS,
            self::UNLOCK_SYNC_MODE_PERIODICALLY,
            self::UNLOCK_SYNC_MODE_NEVER,
        ];
    }
    

    /**
     * Associative array for storing property values
     *
     * @var mixed[]
     */
    protected $container = [];

    /**
     * Constructor
     *
     * @param mixed[] $data Associated array of property values
     *                      initializing the model
     */
    public function __construct(array $data = null)
    {
        $this->container['id'] = isset($data['id']) ? $data['id'] : null;
        $this->container['version'] = isset($data['version']) ? $data['version'] : null;
        $this->container['ownership'] = isset($data['ownership']) ? $data['ownership'] : null;
        $this->container['last_synchronized_on'] = isset($data['last_synchronized_on']) ? $data['last_synchronized_on'] : null;
        $this->container['timezone'] = isset($data['timezone']) ? $data['timezone'] : null;
        $this->container['holiday_calendar_enabled'] = isset($data['holiday_calendar_enabled']) ? $data['holiday_calendar_enabled'] : null;
        $this->container['manual_office_mode_enabled'] = isset($data['manual_office_mode_enabled']) ? $data['manual_office_mode_enabled'] : null;
        $this->container['automatic_office_mode_enabled'] = isset($data['automatic_office_mode_enabled']) ? $data['automatic_office_mode_enabled'] : null;
        $this->container['normal_release_duration'] = isset($data['normal_release_duration']) ? $data['normal_release_duration'] : null;
        $this->container['extended_release_duration'] = isset($data['extended_release_duration']) ? $data['extended_release_duration'] : null;
        $this->container['unlock_sync_mode'] = isset($data['unlock_sync_mode']) ? $data['unlock_sync_mode'] : null;
        $this->container['rs485_log_output_enabled'] = isset($data['rs485_log_output_enabled']) ? $data['rs485_log_output_enabled'] : null;
        $this->container['allow_handsfree_mode'] = isset($data['allow_handsfree_mode']) ? $data['allow_handsfree_mode'] : null;
        $this->container['anonymize_event_log'] = isset($data['anonymize_event_log']) ? $data['anonymize_event_log'] : null;
        $this->container['anonymize_data_in_owner_protocol'] = isset($data['anonymize_data_in_owner_protocol']) ? $data['anonymize_data_in_owner_protocol'] : null;
        $this->container['office_mode_slots'] = isset($data['office_mode_slots']) ? $data['office_mode_slots'] : null;
        $this->container['assigned_areas'] = isset($data['assigned_areas']) ? $data['assigned_areas'] : null;
        $this->container['active_shares'] = isset($data['active_shares']) ? $data['active_shares'] : null;
        $this->container['sharing_codes'] = isset($data['sharing_codes']) ? $data['sharing_codes'] : null;
    }

    /**
     * Show all the invalid properties with reasons.
     *
     * @return array invalid properties with reasons
     */
    public function listInvalidProperties()
    {
        $invalidProperties = [];

        if ($this->container['id'] === null) {
            $invalidProperties[] = "'id' can't be null";
        }
        if ($this->container['version'] === null) {
            $invalidProperties[] = "'version' can't be null";
        }
        $allowedValues = $this->getOwnershipAllowableValues();
        if (!is_null($this->container['ownership']) && !in_array($this->container['ownership'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'ownership', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if (!is_null($this->container['normal_release_duration']) && ($this->container['normal_release_duration'] > 250)) {
            $invalidProperties[] = "invalid value for 'normal_release_duration', must be smaller than or equal to 250.";
        }

        if (!is_null($this->container['normal_release_duration']) && ($this->container['normal_release_duration'] < 1)) {
            $invalidProperties[] = "invalid value for 'normal_release_duration', must be bigger than or equal to 1.";
        }

        if (!is_null($this->container['extended_release_duration']) && ($this->container['extended_release_duration'] > 250)) {
            $invalidProperties[] = "invalid value for 'extended_release_duration', must be smaller than or equal to 250.";
        }

        if (!is_null($this->container['extended_release_duration']) && ($this->container['extended_release_duration'] < 1)) {
            $invalidProperties[] = "invalid value for 'extended_release_duration', must be bigger than or equal to 1.";
        }

        $allowedValues = $this->getUnlockSyncModeAllowableValues();
        if (!is_null($this->container['unlock_sync_mode']) && !in_array($this->container['unlock_sync_mode'], $allowedValues, true)) {
            $invalidProperties[] = sprintf(
                "invalid value for 'unlock_sync_mode', must be one of '%s'",
                implode("', '", $allowedValues)
            );
        }

        if ($this->container['anonymize_event_log'] === null) {
            $invalidProperties[] = "'anonymize_event_log' can't be null";
        }
        return $invalidProperties;
    }

    /**
     * Validate all the properties in the model
     * return true if all passed
     *
     * @return bool True if all properties are valid
     */
    public function valid()
    {
        return count($this->listInvalidProperties()) === 0;
    }


    /**
     * Gets id
     *
     * @return int
     */
    public function getId()
    {
        return $this->container['id'];
    }

    /**
     * Sets id
     *
     * @param int $id Unique identifier
     *
     * @return $this
     */
    public function setId($id)
    {
        $this->container['id'] = $id;

        return $this;
    }

    /**
     * Gets version
     *
     * @return int
     */
    public function getVersion()
    {
        return $this->container['version'];
    }

    /**
     * Sets version
     *
     * @param int $version Current version number of the lock
     *
     * @return $this
     */
    public function setVersion($version)
    {
        $this->container['version'] = $version;

        return $this;
    }

    /**
     * Gets ownership
     *
     * @return string
     */
    public function getOwnership()
    {
        return $this->container['ownership'];
    }

    /**
     * Sets ownership
     *
     * @param string $ownership Describes if the lock is your own or it belongs to someone else who has shared it with you. LockSettings attributes may only be visible or updatable for some ownership values, check specific attribute documentation how it is affected by ownership values.
     *
     * @return $this
     */
    public function setOwnership($ownership)
    {
        $allowedValues = $this->getOwnershipAllowableValues();
        if (!is_null($ownership) && !in_array($ownership, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'ownership', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['ownership'] = $ownership;

        return $this;
    }

    /**
     * Gets last_synchronized_on
     *
     * @return string
     */
    public function getLastSynchronizedOn()
    {
        return $this->container['last_synchronized_on'];
    }

    /**
     * Sets last_synchronized_on
     *
     * @param string $last_synchronized_on Timestamp of the last full synchronization of the lock (ISO 8601-format compliant date with time in UTC, milliseconds precision: yyyy-mm-ddThh:mm:ss.SSSZ)
     *
     * @return $this
     */
    public function setLastSynchronizedOn($last_synchronized_on)
    {
        $this->container['last_synchronized_on'] = $last_synchronized_on;

        return $this;
    }

    /**
     * Gets timezone
     *
     * @return string
     */
    public function getTimezone()
    {
        return $this->container['timezone'];
    }

    /**
     * Sets timezone
     *
     * @param string $timezone Lock specific timezone which affects authorizations that are only valid for certain time frames. Time zone name according to IANA Time Zone Identifier. Needs lock synchronization to be in effect. Cannot be updated if lock ownership=EXTERNAL.
     *
     * @return $this
     */
    public function setTimezone($timezone)
    {
        $this->container['timezone'] = $timezone;

        return $this;
    }

    /**
     * Gets holiday_calendar_enabled
     *
     * @return bool
     */
    public function getHolidayCalendarEnabled()
    {
        return $this->container['holiday_calendar_enabled'];
    }

    /**
     * Sets holiday_calendar_enabled
     *
     * @param bool $holiday_calendar_enabled Enables your global holiday calendar for this lock. Check the HolidayCalendar resource on how to modify your global holiday calendar. PERIODICAL authorizations are not valid on holidays and automatic office mode is ignored on holidays. Needs lock synchronization to be in effect. Cannot be updated if lock ownership=EXTERNAL.
     *
     * @return $this
     */
    public function setHolidayCalendarEnabled($holiday_calendar_enabled)
    {
        $this->container['holiday_calendar_enabled'] = $holiday_calendar_enabled;

        return $this;
    }

    /**
     * Gets manual_office_mode_enabled
     *
     * @return bool
     */
    public function getManualOfficeModeEnabled()
    {
        return $this->container['manual_office_mode_enabled'];
    }

    /**
     * Sets manual_office_mode_enabled
     *
     * @param bool $manual_office_mode_enabled Allows the lock to be in office mode which is a state where the lock is permanently released so there is no need to present an authorized medium to release the lock every time. Only media that is (globally, for all your locks) authorized to activate/deactivate the office mode can trigger this lock state. Office mode can also be triggered by someone else if you share this lock with someone else and enable this setting. Needs lock synchronization to be in effect. Cannot be updated if lock ownership=EXTERNAL.
     *
     * @return $this
     */
    public function setManualOfficeModeEnabled($manual_office_mode_enabled)
    {
        $this->container['manual_office_mode_enabled'] = $manual_office_mode_enabled;

        return $this;
    }

    /**
     * Gets automatic_office_mode_enabled
     *
     * @return bool
     */
    public function getAutomaticOfficeModeEnabled()
    {
        return $this->container['automatic_office_mode_enabled'];
    }

    /**
     * Sets automatic_office_mode_enabled
     *
     * @param bool $automatic_office_mode_enabled Allows the office mode to be enabled automatically. The effects are the same as in manually activated office mode, difference being that the office mode is entered/left automatically at a specific time that you can define. Opening/Closing times can be defined with the officeModeSlots attribute. Can only be enabled if manual office mode is also enabled. Needs lock synchronization to be in effect.
     *
     * @return $this
     */
    public function setAutomaticOfficeModeEnabled($automatic_office_mode_enabled)
    {
        $this->container['automatic_office_mode_enabled'] = $automatic_office_mode_enabled;

        return $this;
    }

    /**
     * Gets normal_release_duration
     *
     * @return int
     */
    public function getNormalReleaseDuration()
    {
        return $this->container['normal_release_duration'];
    }

    /**
     * Sets normal_release_duration
     *
     * @param int $normal_release_duration Standard release duration in seconds. Needs lock synchronization to be in effect. Cannot be updated if lock ownership=EXTERNAL.
     *
     * @return $this
     */
    public function setNormalReleaseDuration($normal_release_duration)
    {

        if (!is_null($normal_release_duration) && ($normal_release_duration > 250)) {
            throw new \InvalidArgumentException('invalid value for $normal_release_duration when calling LockSettings., must be smaller than or equal to 250.');
        }
        if (!is_null($normal_release_duration) && ($normal_release_duration < 1)) {
            throw new \InvalidArgumentException('invalid value for $normal_release_duration when calling LockSettings., must be bigger than or equal to 1.');
        }

        $this->container['normal_release_duration'] = $normal_release_duration;

        return $this;
    }

    /**
     * Gets extended_release_duration
     *
     * @return int
     */
    public function getExtendedReleaseDuration()
    {
        return $this->container['extended_release_duration'];
    }

    /**
     * Sets extended_release_duration
     *
     * @param int $extended_release_duration Alternative (usually but not necessarily longer) release duration. Is used by media that is configured to use the alternative release duration. Needs lock synchronization to be in effect. Cannot be updated if lock ownership=EXTERNAL.
     *
     * @return $this
     */
    public function setExtendedReleaseDuration($extended_release_duration)
    {

        if (!is_null($extended_release_duration) && ($extended_release_duration > 250)) {
            throw new \InvalidArgumentException('invalid value for $extended_release_duration when calling LockSettings., must be smaller than or equal to 250.');
        }
        if (!is_null($extended_release_duration) && ($extended_release_duration < 1)) {
            throw new \InvalidArgumentException('invalid value for $extended_release_duration when calling LockSettings., must be bigger than or equal to 1.');
        }

        $this->container['extended_release_duration'] = $extended_release_duration;

        return $this;
    }

    /**
     * Gets unlock_sync_mode
     *
     * @return string
     */
    public function getUnlockSyncMode()
    {
        return $this->container['unlock_sync_mode'];
    }

    /**
     * Sets unlock_sync_mode
     *
     * @param string $unlock_sync_mode Determines if and when the lock is synchronized after it is unlocked by a smartphone via Bluetooth.  May only be a partial synchronization (depends on how long the mobile phone stays in range). Use value PERIODICALLY if you want to synchronize the lock only every few hours or if important maintenance tasks exist. Cannot be updated if lock ownership=EXTERNAL.
     *
     * @return $this
     */
    public function setUnlockSyncMode($unlock_sync_mode)
    {
        $allowedValues = $this->getUnlockSyncModeAllowableValues();
        if (!is_null($unlock_sync_mode) && !in_array($unlock_sync_mode, $allowedValues, true)) {
            throw new \InvalidArgumentException(
                sprintf(
                    "Invalid value for 'unlock_sync_mode', must be one of '%s'",
                    implode("', '", $allowedValues)
                )
            );
        }
        $this->container['unlock_sync_mode'] = $unlock_sync_mode;

        return $this;
    }

    /**
     * Gets rs485_log_output_enabled
     *
     * @return bool
     */
    public function getRs485LogOutputEnabled()
    {
        return $this->container['rs485_log_output_enabled'];
    }

    /**
     * Sets rs485_log_output_enabled
     *
     * @param bool $rs485_log_output_enabled Log output is forwarded to a third-party system via the RS485 interface, if enabled. Needs lock synchronization to be in effect. Can only be updated for locks of type WALLREADER and if lock ownership=OWNER.
     *
     * @return $this
     */
    public function setRs485LogOutputEnabled($rs485_log_output_enabled)
    {
        $this->container['rs485_log_output_enabled'] = $rs485_log_output_enabled;

        return $this;
    }

    /**
     * Gets allow_handsfree_mode
     *
     * @return bool
     */
    public function getAllowHandsfreeMode()
    {
        return $this->container['allow_handsfree_mode'];
    }

    /**
     * Sets allow_handsfree_mode
     *
     * @param bool $allow_handsfree_mode Allows the hands-free mode to be used to unlock this lock. A smartphone user can use hands-free mode to unlock a lock automatically at a given distance to the lock. Only possible if the specific lock allows hands-free mode. Cannot be updated if lock ownership=EXTERNAL.
     *
     * @return $this
     */
    public function setAllowHandsfreeMode($allow_handsfree_mode)
    {
        $this->container['allow_handsfree_mode'] = $allow_handsfree_mode;

        return $this;
    }

    /**
     * Gets anonymize_event_log
     *
     * @return \Coucounco\Airkey\Swagger\Client\Model\AnonymizeEventLog
     */
    public function getAnonymizeEventLog()
    {
        return $this->container['anonymize_event_log'];
    }

    /**
     * Sets anonymize_event_log
     *
     * @param \Coucounco\Airkey\Swagger\Client\Model\AnonymizeEventLog $anonymize_event_log Determines whether your own lock protocol entries should be anonymized. Anonymization removes references to used media and associated persons.
     *
     * @return $this
     */
    public function setAnonymizeEventLog($anonymize_event_log)
    {
        $this->container['anonymize_event_log'] = $anonymize_event_log;

        return $this;
    }

    /**
     * Gets anonymize_data_in_owner_protocol
     *
     * @return bool
     */
    public function getAnonymizeDataInOwnerProtocol()
    {
        return $this->container['anonymize_data_in_owner_protocol'];
    }

    /**
     * Sets anonymize_data_in_owner_protocol
     *
     * @param bool $anonymize_data_in_owner_protocol Determines whether lock owner's lock protocol entries should be anonymized. Anonymization removes references to used media and associated persons. Only affects entries that include your media, not the lock owner's media. Can only be seen and updated if lock ownership=EXTERNAL.
     *
     * @return $this
     */
    public function setAnonymizeDataInOwnerProtocol($anonymize_data_in_owner_protocol)
    {
        $this->container['anonymize_data_in_owner_protocol'] = $anonymize_data_in_owner_protocol;

        return $this;
    }

    /**
     * Gets office_mode_slots
     *
     * @return \Coucounco\Airkey\Swagger\Client\Model\OfficeModeSlot[]
     */
    public function getOfficeModeSlots()
    {
        return $this->container['office_mode_slots'];
    }

    /**
     * Sets office_mode_slots
     *
     * @param \Coucounco\Airkey\Swagger\Client\Model\OfficeModeSlot[] $office_mode_slots List of office mode slots. Allows a lock to enter/leave the office mode automatically at a specific time. Only in effect if automaticOfficeModeEnabled is set to true and the lock has been synchronized.
     *
     * @return $this
     */
    public function setOfficeModeSlots($office_mode_slots)
    {
        $this->container['office_mode_slots'] = $office_mode_slots;

        return $this;
    }

    /**
     * Gets assigned_areas
     *
     * @return \Coucounco\Airkey\Swagger\Client\Model\AssignedArea[]
     */
    public function getAssignedAreas()
    {
        return $this->container['assigned_areas'];
    }

    /**
     * Sets assigned_areas
     *
     * @param \Coucounco\Airkey\Swagger\Client\Model\AssignedArea[] $assigned_areas List of assigned areas
     *
     * @return $this
     */
    public function setAssignedAreas($assigned_areas)
    {
        $this->container['assigned_areas'] = $assigned_areas;

        return $this;
    }

    /**
     * Gets active_shares
     *
     * @return \Coucounco\Airkey\Swagger\Client\Model\ActiveShare[]
     */
    public function getActiveShares()
    {
        return $this->container['active_shares'];
    }

    /**
     * Sets active_shares
     *
     * @param \Coucounco\Airkey\Swagger\Client\Model\ActiveShare[] $active_shares List of shares of the locking component for other AirKey systems
     *
     * @return $this
     */
    public function setActiveShares($active_shares)
    {
        $this->container['active_shares'] = $active_shares;

        return $this;
    }

    /**
     * Gets sharing_codes
     *
     * @return \Coucounco\Airkey\Swagger\Client\Model\SharingCode[]
     */
    public function getSharingCodes()
    {
        return $this->container['sharing_codes'];
    }

    /**
     * Sets sharing_codes
     *
     * @param \Coucounco\Airkey\Swagger\Client\Model\SharingCode[] $sharing_codes List of sharing codes for a locking component
     *
     * @return $this
     */
    public function setSharingCodes($sharing_codes)
    {
        $this->container['sharing_codes'] = $sharing_codes;

        return $this;
    }
    /**
     * Returns true if offset exists. False otherwise.
     *
     * @param integer $offset Offset
     *
     * @return boolean
     */
    #[\ReturnTypeWillChange]
    public function offsetExists($offset)
    {
        return isset($this->container[$offset]);
    }

    /**
     * Gets offset.
     *
     * @param integer $offset Offset
     *
     * @return mixed
     */
    #[\ReturnTypeWillChange]
    public function offsetGet($offset)
    {
        return isset($this->container[$offset]) ? $this->container[$offset] : null;
    }

    /**
     * Sets value based on offset.
     *
     * @param integer $offset Offset
     * @param mixed   $value  Value to be set
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetSet($offset, $value)
    {
        if (is_null($offset)) {
            $this->container[] = $value;
        } else {
            $this->container[$offset] = $value;
        }
    }

    /**
     * Unsets offset.
     *
     * @param integer $offset Offset
     *
     * @return void
     */
    #[\ReturnTypeWillChange]
    public function offsetUnset($offset)
    {
        unset($this->container[$offset]);
    }

    /**
     * Gets the string presentation of the object
     *
     * @return string
     */
    public function __toString()
    {
        if (defined('JSON_PRETTY_PRINT')) { // use JSON pretty print
            return json_encode(
                ObjectSerializer::sanitizeForSerialization($this),
                JSON_PRETTY_PRINT
            );
        }

        return json_encode(ObjectSerializer::sanitizeForSerialization($this));
    }
}


